package internal

import (
	"bytes"
	"fmt"
	. "github.com/dave/jennifer/jen"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"os"
	"path/filepath"
	"slices"
	"sort"
	"strings"
)

var http_Verbs = []string{"GET", "POST", "PUT", "DELETE"}

func Build(input_dir string, output_filename string, pkgName string) error {

	merger := NewMerger(pkgName)
	if err := merger.ParseDir(input_dir, output_filename+".go"); err != nil {
		return err
	}

	merger.buildGenDecl()

	funcs := merger.sortAddedFuncs()

	var routes []Code

	for _, decl := range funcs {

		name := decl.Name.Name

		split := strings.Split(name, "_")

		for index, element := range split {
			if element[0:1] == ":" {

				new := split
				new[index] = element[1:]

				decl.Name.Name = strings.Join(new, "_")
			}
		}

		func_Name := decl.Name.Name

		merger.tree.Decls = append(merger.tree.Decls, decl)

		if len(split) < 2 {
			continue
		}

		verb := split[0]

		path := strings.Split(strings.ReplaceAll(name, "_", "/"), "routes/")[1]

		f := Code(Qual("e", verb).Call(List(Lit(path), Id(func_Name))))

		routes = append(routes, f)

	}

	var buf bytes.Buffer

	if err := printer.Fprint(&buf, token.NewFileSet(), merger.tree); err != nil {
		return err
	}

	merged := buf.String()

	f := Func().Id("registerRoutes").Params(Id("e").Id("*echo.Echo")).Block(
		routes...,
	)
	codeAsString := fmt.Sprintf("%#v", f)

	header := "// Automatically generated by gen_routes.go, DO NOT EDIT manually" + "\n"

	if err := os.WriteFile(output_filename+".go", []byte(header+merged+"\n"+codeAsString), 0666); err != nil {
		return err
	}

	return nil
}

/*
MIT License

Copyright (c) 2023 Dmitrii Barsukov

https://github.com/mrsombre/codingame-golang-merger
*/

type Merger struct {
	tree         *ast.File
	addedImports map[string]ast.Spec
	addedConsts  map[string]ast.Spec
	addedTypes   map[string]ast.Spec
	addedVars    map[string]ast.Spec
	addedFunc    map[string]*ast.FuncDecl
	specialFunc  map[string]bool
}

func NewMerger(pkgName string) *Merger {
	merger := &Merger{
		tree: &ast.File{
			Name: ast.NewIdent(pkgName),
		},
		addedImports: make(map[string]ast.Spec),
		addedConsts:  make(map[string]ast.Spec),
		addedTypes:   make(map[string]ast.Spec),
		addedVars:    make(map[string]ast.Spec),
		addedFunc:    make(map[string]*ast.FuncDecl),
		specialFunc:  map[string]bool{`init`: true, `main`: true},
	}

	return merger
}

func (m *Merger) ParseDir(dirName, sourceName string) error {
	cnt := 0

	err := filepath.WalkDir(dirName, func(path string, d os.DirEntry, err error) error {
		if err != nil {
			return err
		}

		if d.IsDir() {
			return nil
		}

		filename := d.Name()

		if strings.HasSuffix(filename, "_test.go") || !strings.HasSuffix(filename, ".go") || filename == sourceName {
			return nil
		}

		if err := m.parseFile(path); err != nil {
			return err
		}
		cnt++
		return nil
	})

	if err != nil {
		return err
	}

	// If no Go files are found, return an error
	if cnt == 0 {
		realpath, _ := filepath.Abs(dirName)
		return fmt.Errorf("no Go source files found in %s", realpath)
	}

	return nil
}
func (m *Merger) parseFile(path string) error {
	fset := token.NewFileSet()

	file, err := parser.ParseFile(fset, path, nil, 0)
	if err != nil {
		return err
	}

	for i, decl := range file.Decls {
		if gen, ok := decl.(*ast.GenDecl); ok {
			if gen.Tok == token.PACKAGE {
				file.Decls = append(file.Decls[:i], file.Decls[i+1:]...)
				break
			}
		}
	}

	for _, decl := range file.Decls {
		switch decl := decl.(type) {
		case *ast.GenDecl:
			m.parseGenDecl(decl)
		case *ast.FuncDecl:
			name := decl.Name.Name
			if _, ok := m.specialFunc[name]; !ok {
				name = fset.Position(decl.Pos()).String()
			}
			// add path to function name when http verb
			func_Name := strings.ToUpper(decl.Name.Name)
			if slices.Contains(http_Verbs, strings.Split(func_Name, "_")[0]) {

				route := strings.ReplaceAll(strings.TrimSuffix(path, ".go"), "/", "_")

				if route[len(route)-1:] == ":" {

					split := strings.Split(route, "_")
					element := split[len(split)-1]

					route = strings.Join(split[0:len(split)-1], "_") + "_:" + element[0:len(element)-1]

				}

				// look if there is a problem with windows IDK :)
				decl.Name.Name = func_Name + "_" + route
			}

			m.addedFunc[name] = decl
		}
	}

	return nil
}

func (m *Merger) parseGenDecl(decl *ast.GenDecl) {
	switch decl.Tok {
	case token.IMPORT:
		for _, spec := range decl.Specs {
			if v, ok := spec.(*ast.ImportSpec); ok {
				m.addedImports[v.Path.Value] = spec
			}
		}
	case token.CONST:
		for _, spec := range decl.Specs {
			if v, ok := spec.(*ast.ValueSpec); ok {
				for _, name := range v.Names {
					m.addedConsts[name.Name] = spec
				}
			}
		}
	case token.TYPE:
		for _, spec := range decl.Specs {
			if t, ok := spec.(*ast.TypeSpec); ok {
				m.addedTypes[t.Name.Name] = spec
			}
		}
	case token.VAR:
		for _, spec := range decl.Specs {
			if v, ok := spec.(*ast.ValueSpec); ok {
				for _, name := range v.Names {
					m.addedVars[name.Name] = spec
				}
			}
		}
	}
}

func (m *Merger) buildGenDecl() {
	var specs []ast.Spec

	specs = make([]ast.Spec, 0, len(m.addedImports))
	for _, spec := range m.addedImports {
		specs = append(specs, spec)
	}
	if len(specs) > 0 {
		m.tree.Decls = append(m.tree.Decls, &ast.GenDecl{
			Tok:   token.IMPORT,
			Specs: specs,
		})
	}

	specs = make([]ast.Spec, 0, len(m.addedConsts))
	for _, spec := range m.addedConsts {
		specs = append(specs, spec)
	}
	if len(specs) > 0 {
		m.tree.Decls = append(m.tree.Decls, &ast.GenDecl{
			Tok:   token.CONST,
			Specs: specs,
		})
	}

	specs = make([]ast.Spec, 0, len(m.addedVars))
	for _, spec := range m.addedVars {
		specs = append(specs, spec)
	}
	if len(specs) > 0 {
		m.tree.Decls = append(m.tree.Decls, &ast.GenDecl{
			Tok:   token.VAR,
			Specs: specs,
		})
	}

	specs = make([]ast.Spec, 0, len(m.addedTypes))
	for _, spec := range m.addedTypes {
		specs = append(specs, spec)
	}
	if len(specs) > 0 {
		m.tree.Decls = append(m.tree.Decls, &ast.GenDecl{
			Tok:   token.TYPE,
			Specs: specs,
		})
	}
}

func (m *Merger) sortAddedFuncs() []*ast.FuncDecl {
	keys := make([]string, 0, len(m.addedFunc))
	for k := range m.addedFunc {
		if _, ok := m.specialFunc[k]; ok {
			continue
		}
		keys = append(keys, k)
	}

	sort.Strings(keys)

	sortedFuncs := make([]*ast.FuncDecl, len(keys))
	for i, k := range keys {
		decl := m.addedFunc[k]
		sortedFuncs[i] = decl
	}

	for k := range m.specialFunc {
		if _, ok := m.addedFunc[k]; !ok {
			continue
		}
		decl := m.addedFunc[k]
		sortedFuncs = append(sortedFuncs, decl)
	}

	return sortedFuncs
}
